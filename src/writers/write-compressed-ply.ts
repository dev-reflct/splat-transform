import { version } from '../../package.json';
import { CompressedChunk } from '../compressed-chunk';
import { DataTable } from '../data-table';
import { generateOrdering } from '../ordering';

const generatedByString = `Generated by splat-transform ${version}`;

const chunkProps = [
    'min_x',
    'min_y',
    'min_z',
    'max_x',
    'max_y',
    'max_z',
    'min_scale_x',
    'min_scale_y',
    'min_scale_z',
    'max_scale_x',
    'max_scale_y',
    'max_scale_z',
    'min_r',
    'min_g',
    'min_b',
    'max_r',
    'max_g',
    'max_b',
];

const vertexProps = ['packed_position', 'packed_rotation', 'packed_scale', 'packed_color'];

const shNames = new Array(45).fill('').map((_, i) => `f_rest_${i}`);

/**
 * Write compressed PLY data to an ArrayBuffer
 * @param dataTable - The DataTable to compress and write
 * @returns ArrayBuffer containing the compressed PLY data
 */
export const writeCompressedPlyToBuffer = (dataTable: DataTable): ArrayBuffer => {
    const shBands =
        { '9': 1, '24': 2, '-1': 3 }[shNames.findIndex(v => !dataTable.hasColumn(v))] ?? 0;
    const outputSHCoeffs = [0, 3, 8, 15][shBands];

    const numSplats = dataTable.numRows;
    const numChunks = Math.ceil(numSplats / 256);

    const shHeader = shBands
        ? [
              `element sh ${numSplats}`,
              new Array(outputSHCoeffs * 3).fill('').map((_, i) => `property uchar f_rest_${i}`),
          ].flat()
        : [];

    const headerText = [
        'ply',
        'format binary_little_endian 1.0',
        `comment ${generatedByString}`,
        `element chunk ${numChunks}`,
        chunkProps.map(p => `property float ${p}`),
        `element vertex ${numSplats}`,
        vertexProps.map(p => `property uint ${p}`),
        shHeader,
        'end_header\n',
    ]
        .flat()
        .join('\n');

    const header = new TextEncoder().encode(headerText);
    const chunkData = new Float32Array(numChunks * chunkProps.length);
    const splatIData = new Uint32Array(numSplats * vertexProps.length);
    const shData = new Uint8Array(numSplats * outputSHCoeffs * 3);

    // sort splats into some kind of order (morton order rn)
    const sortIndices = generateOrdering(dataTable);

    const row: any = {};

    const chunk = new CompressedChunk();

    for (let i = 0; i < numChunks; ++i) {
        const num = Math.min(numSplats, (i + 1) * 256) - i * 256;
        for (let j = 0; j < num; ++j) {
            const index = sortIndices[i * 256 + j];

            // read splat data
            dataTable.getRow(index, row);

            // update chunk
            chunk.set(j, row);

            // quantize and write sh data
            let off = (i * 256 + j) * outputSHCoeffs * 3;
            for (let k = 0; k < outputSHCoeffs * 3; ++k) {
                const nvalue = row[shNames[k]] / 8 + 0.5;
                shData[off++] = Math.max(0, Math.min(255, Math.trunc(nvalue * 256)));
            }
        }

        // repeat the last gaussian to fill the rest of the final chunk
        for (let j = num; j < 256; ++j) {
            chunk.set(j, row);
        }

        // pack the chunk
        chunk.pack();

        // store the float data
        chunkData.set(chunk.chunkData, i * 18);

        // write packed bits
        const offset = i * 256 * 4;
        for (let j = 0; j < num; ++j) {
            splatIData[offset + j * 4 + 0] = chunk.position[j];
            splatIData[offset + j * 4 + 1] = chunk.rotation[j];
            splatIData[offset + j * 4 + 2] = chunk.scale[j];
            splatIData[offset + j * 4 + 3] = chunk.color[j];
        }
    }

    // Calculate total size
    const totalSize =
        header.length + chunkData.byteLength + splatIData.byteLength + shData.byteLength;
    const buffer = new ArrayBuffer(totalSize);
    const uint8Array = new Uint8Array(buffer);
    let offset = 0;

    // Write header
    uint8Array.set(header, offset);
    offset += header.length;

    // Write chunk data
    uint8Array.set(new Uint8Array(chunkData.buffer), offset);
    offset += chunkData.byteLength;

    // Write splat data
    uint8Array.set(new Uint8Array(splatIData.buffer), offset);
    offset += splatIData.byteLength;

    // Write SH data
    uint8Array.set(shData, offset);

    return buffer;
};

/**
 * Write compressed PLY data to a Blob
 * @param dataTable - The DataTable to compress and write
 * @returns Blob containing the compressed PLY data
 */
export const writeCompressedPlyToBlob = (dataTable: DataTable): Blob => {
    const buffer = writeCompressedPlyToBuffer(dataTable);
    return new Blob([buffer], { type: 'application/octet-stream' });
};

/**
 * Write compressed PLY data to a file handle (legacy function for backward compatibility)
 * @param fileHandle - The file handle to write to
 * @param dataTable - The DataTable to compress and write
 * @returns Promise that resolves when writing is complete
 */
export const writeCompressedPly = async (fileHandle: any, dataTable: DataTable): Promise<void> => {
    if (fileHandle && typeof fileHandle.write === 'function') {
        // Node.js file handle
        const buffer = writeCompressedPlyToBuffer(dataTable);
        await fileHandle.write(new Uint8Array(buffer));
    } else {
        throw new Error(
            'Unsupported file handle type. Use writeCompressedPlyToBuffer or writeCompressedPlyToBlob for browser compatibility.'
        );
    }
};
